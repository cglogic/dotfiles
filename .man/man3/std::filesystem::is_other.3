.TH std::filesystem::is_other 3 "2018.03.28" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::filesystem::is_other \- std::filesystem::is_other

.SH Synopsis
   Defined in header <filesystem>
   bool is_other( std::filesystem::file_status s );                   \fB(1)\fP \fI(since C++17)\fP
   bool is_other( const std::filesystem::path& p );
   bool is_other( const std::filesystem::path& p, std::error_code& ec \fB(2)\fP \fI(since C++17)\fP
   );

   Checks if the given file status or path corresponds to a file of type other type.
   That is, the file exists, but is neither regular file, nor directory nor a symlink.

   1) Equivalent to exists(s) && !is_regular_file(s) && !is_directory(s) &&
   !is_symlink(s).
   2) Equivalent to is_other(status(p)) or is_other(status(p, ec)), respectively.

.SH Parameters

   s  - file status to check
   p  - path to examine
   ec - error code to store the error status to

.SH Return value

   true if the file indicated by p or if the type indicated s refers to a file that is
   not regular file, directory, or a symlink, false otherwise. The non-throwing
   overload returns false if an error occurs.

.SH Exceptions

   1)
   noexcept specification:
   noexcept
   2) The overload that does not take a std::error_code& parameter throws
   filesystem_error on underlying OS API errors, constructed with p as the first
   argument and the OS error code as the error code argument. std::bad_alloc may be
   thrown if memory allocation fails. The overload taking a std::error_code& parameter
   sets it to the OS API error code if an OS API call fails, and executes ec.clear() if
   no errors occur. This overload has
   noexcept specification:
   noexcept

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   status            determines file attributes
   symlink_status    determines file attributes, checking the symlink target
   \fI(C++17)\fP           \fI(function)\fP
   \fI(C++17)\fP
   file_status       represents file type and permissions
   \fI(C++17)\fP           \fI(class)\fP
   status_known      checks whether file status is known
   \fI(C++17)\fP           \fI(function)\fP
   is_block_file     checks whether the given path refers to block device
   \fI(C++17)\fP           \fI(function)\fP
   is_character_file checks whether the given path refers to a character device
   \fI(C++17)\fP           \fI(function)\fP
   is_directory      checks whether the given path refers to a directory
   \fI(C++17)\fP           \fI(function)\fP
   is_fifo           checks whether the given path refers to a named pipe
   \fI(C++17)\fP           \fI(function)\fP
   is_regular_file   checks whether the argument refers to a regular file
   \fI(C++17)\fP           \fI(function)\fP
   is_socket         checks whether the argument refers to a named IPC socket
   \fI(C++17)\fP           \fI(function)\fP
   is_symlink        checks whether the argument refers to a symbolic link
   \fI(C++17)\fP           \fI(function)\fP
   exists            checks whether path refers to existing file system object
   \fI(C++17)\fP           \fI(function)\fP
   status            status of the file designated by this directory entry
   symlink_status    symlink_status of the file designated by this directory entry
                     \fI(public member function of std::filesystem::directory_entry)\fP

   Categories:

     * unconditionally noexcept
     * Todo no example

   Hidden categories:

     * Pages with unreviewed unconditional noexcept template
     * Pages with unreviewed noexcept template
